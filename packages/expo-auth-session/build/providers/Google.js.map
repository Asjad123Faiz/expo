{"version":3,"file":"Google.js","sourceRoot":"","sources":["../../src/providers/Google.ts"],"names":[],"mappings":"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","sourcesContent":["import { useEffect, useState } from 'react';\n\nimport { useAuthRequestResult, useLoadedAuthRequest } from '../AuthRequestHooks';\nimport {\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  AuthSessionResult,\n  DiscoveryDocument,\n  generateHexStringAsync,\n  Prompt,\n  ResponseType,\n} from '../AuthSession';\nimport {\n  AccessTokenRequest,\n  fetchUserInfoAsync as _fetchUserInfoAsync,\n  TokenResponse,\n} from '../TokenRequest';\nimport { ProviderAuthRequestConfig, ProviderUser } from './Provider.types';\n\nconst settings = {\n  windowFeatures: { width: 515, height: 680 },\n  minimumScopes: [\n    'openid',\n    'https://www.googleapis.com/auth/userinfo.profile',\n    'https://www.googleapis.com/auth/userinfo.email',\n  ],\n};\n\n// Updated Jun 22, 2020\nexport const discovery: DiscoveryDocument = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo',\n};\n\nexport interface GoogleAuthRequestConfig extends ProviderAuthRequestConfig {\n  /**\n   * If the user's email address is known ahead of time, it can be supplied to be the default option.\n   * If the user has approved access for this app in the past then auth may return without any further interaction.\n   */\n  loginHint?: string;\n}\n\nfunction applyRequiredScopes(scopes: string[] = []): string[] {\n  // Add the required scopes for returning profile data.\n  const requiredScopes = [...scopes, ...settings.minimumScopes];\n  // Remove duplicates\n  return [...new Set(requiredScopes)];\n}\n\nclass GoogleAuthRequest extends AuthRequest {\n  nonce?: string;\n\n  constructor({\n    language,\n    loginHint,\n    selectAccount,\n    extraParams = {},\n    clientSecret,\n    ...config\n  }: GoogleAuthRequestConfig) {\n    const inputParams = {\n      ...extraParams,\n    };\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = Prompt.SelectAccount;\n\n    // Apply the default scopes\n    const scopes = applyRequiredScopes(config.scopes);\n    const isImplicit = config.responseType === ResponseType.Token;\n    if (isImplicit) {\n      // PKCE must be disabled in implicit mode.\n      config.usePKCE = false;\n    }\n    let inputClientSecret: string | undefined;\n    //  Google will throw if you attempt to use the client secret\n    if (config.responseType && config.responseType !== ResponseType.Code) {\n      // TODO: maybe warn that you shouldn't store the client secret on the client\n      inputClientSecret = clientSecret;\n    }\n    super({\n      ...config,\n      clientSecret: inputClientSecret,\n      scopes,\n      extraParams: inputParams,\n    });\n  }\n\n  /**\n   * Load and return a valid auth request based on the input config.\n   */\n  async getAuthRequestConfigAsync(): Promise<AuthRequestConfig> {\n    const { extraParams = {}, ...config } = await super.getAuthRequestConfigAsync();\n    if (config.responseType === ResponseType.IdToken && !extraParams.nonce && !this.nonce) {\n      if (!this.nonce) {\n        this.nonce = await generateHexStringAsync(16);\n      }\n      extraParams.nonce = this.nonce;\n    }\n    return {\n      ...config,\n      extraParams,\n    };\n  }\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n *  - TODO: Put Getting started guide URL here\n *\n * @param config\n * @param discovery\n */\nexport function useAuthRequest(\n  config: GoogleAuthRequestConfig\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const request = useLoadedAuthRequest(config, discovery, GoogleAuthRequest);\n  const [result, promptAsync] = useAuthRequestResult(request, discovery, {\n    windowFeatures: settings.windowFeatures,\n  });\n  const [fullResult, setFullResult] = useState<AuthSessionResult | null>(null);\n  // TODO: warn if running in the expo client and not using proxy\n  // TODO add user info\n  useEffect(() => {\n    let isMounted = true;\n    if (\n      !fullResult &&\n      config.clientSecret &&\n      request?.responseType === ResponseType.Code &&\n      result?.type === 'success'\n    ) {\n      const exchangeRequest = new AccessTokenRequest({\n        clientId: config.clientId,\n        clientSecret: config.clientSecret,\n        redirectUri: config.redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          // @ts-ignore: allow for instances where PKCE is disabled\n          code_verifier: request.codeVerifier,\n        },\n      });\n      exchangeRequest.performAsync(discovery).then(authentication => {\n        if (isMounted) {\n          setFullResult({\n            ...result,\n            authentication,\n          });\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [\n    config.clientId,\n    config.clientSecret,\n    config.redirectUri,\n    config.scopes?.join(','),\n    request?.codeVerifier,\n    request?.responseType,\n    config.responseType,\n    result,\n    fullResult,\n  ]);\n\n  return [request, fullResult, promptAsync];\n}\n\n/**\n * Fetch generic user info from the provider's OpenID Connect `userInfoEndpoint` (if supported).\n *\n * [UserInfo](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)\n *\n * @param config The `accessToken` for a user, returned from a code exchange or auth request.\n * @param discovery The `userInfoEndpoint` for a provider.\n */\nexport async function fetchUserInfoAsync(\n  response: Pick<TokenResponse, 'accessToken'>\n): Promise<ProviderUser> {\n  const providerData = await _fetchUserInfoAsync(response, discovery);\n\n  const user = {\n    name: providerData.name,\n    email: providerData.email,\n    id: providerData.id,\n    picture: providerData.picture,\n    providerData,\n  };\n  return user;\n}\n"]}